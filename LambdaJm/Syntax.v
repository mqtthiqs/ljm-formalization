(***********************************************************************)
(** * Definition of LambdaJm *)
(***********************************************************************)

(** This file containes all of the definitions for a locally-nameless
    representation of the intuitionistic sequent calculus lambda-Jm .  *)


Require Import Metalib.Metatheory.
Require Export ELambda.Definitions. (* just for [typ] *)

(***********************************************************************)
(** * Syntax of LambdaJm *)
(***********************************************************************)

(** We use a locally nameless representation for the LambdaJm 
    calculus, where bound variables are represented as natural numbers
    (de Bruijn indices) and free variables are represented as [atom]s.

    The type [atom], defined in the Metatheory library, represents names.
    Equality on names is decidable, and it is possible to generate an
    atom fresh for any given finite set of atoms ([atom_fresh]).

    Note: the type [var] is notation for [atom].  *)

Definition typ := ELambda.Definitions.typ.


Inductive term : Set :=    (*r proof terms *)
   | var_b (_:nat)
   | var_f (x:var)
   | abs (t:term)
   | app (t:term) (a:gmargs)
with gmargs : Set :=       (*r gm-arguments *)
   | args (u:term) (l:alist) (c:cont)
with alist : Set :=        (* lists *)
   | anil
   | acons (t:term) (l:alist)
with cont : Set :=         (*r continuations *)
   | cabs (v:term).


(** Coq's generation of T_ind principles is incomplete. 
    We only get non-mutual induction principles generated by default.
    We must ask for mutual principles as we need them, using the Scheme command. *)

Scheme term_ind_4 := Induction for term Sort Prop
  with gmargs_ind_4 := Induction for gmargs Sort Prop
  with alist_ind_4 := Induction for alist Sort Prop
  with cont_ind_4 := Induction for cont Sort Prop.


Combined Scheme term_gmargs_alist_cont_mutind from
         term_ind_4, gmargs_ind_4, alist_ind_4, cont_ind_4.




(***********************************************************************)
(** * Substitution *)
(***********************************************************************)

(** Substitution replaces a free variable with a term.  
    The definition below is simple for two reasons:
      - Because bound variables are represented using indices, there
        is no need to worry about variable capture.
      - We assume that the term being substituted in is locally
        closed.  Thus, there is no need to shift indices when
        passing under a binder.
*)

(** The [Fixpoint] keyword defines a Coq function.  As all functions in
    Coq must be total.  The annotation [{struct e}] indicates the
    termination metric---all recursive calls in this definition are made
    to arguments that are structurally smaller than [e].

    Note also that [subst_term] uses [x == y] for decidable equality.
    This operation is defined in the Metatheory library.  *)

Fixpoint subst_term (u:term) (y:var) (e:term) {struct e} : term :=
  match e with
  | (var_b n)  => var_b n
  | (var_f x)  => (if x == y then u else (var_f x))
  | (abs t)    => abs (subst_term u y t)
  | (app t a)  => app (subst_term u y t) (subst_args u y a)
  end
with subst_args (u:term) (y:var) (a:gmargs) {struct a} : gmargs :=
  match a with
  | (args t l c) => args (subst_term u y t) (subst_alist u y l) (subst_cont u y c)
  end
with subst_alist (u:term) (y:var) (l:alist) {struct l} : alist :=
  match l with
  | anil        => anil
  | acons t l1  => acons (subst_term u y t) (subst_alist u y l1)
  end
with subst_cont (u:term) (y:var) (c:cont) {struct c} : cont :=
  match c with
  | (cabs t)  => cabs (subst_term u y t)
  end.

(***********************************************************************)
(** * Free variables *)
(***********************************************************************)

(** The function [fv_term], defined below, calculates the set of free
    variables in an expression.  Because we are using a locally
    nameless representation, where bound variables are represented as
    indices, any name we see is a free variable of a term.  In
    particular, this makes the [abs] case simple.
 *)


Fixpoint fv_term (e:term) : vars :=
  match e with
  | (var_b n) => {}
  | (var_f x)   => {{x}}
  | (abs t)     => fv_term t
  | (app t a)   => fv_term t `union` fv_args a
  end
with fv_args (a:gmargs) : vars :=
  match a with
  | (args t l c)  =>  fv_term t `union` fv_alist l `union` fv_cont c
  end
with fv_alist (l:alist) {struct l} : vars :=
  match l with
  | anil     => {}
  | (acons t l1)  =>  (fv_term t) `union` (fv_alist l1)                      
  end
with fv_cont (c:cont) : vars :=
  match c with
  | (cabs t)  => fv_term t
  end.


        

(** the type [vars] represents a finite set of elements of type [atom].
    The notations for the finite set definitions (empty set `{}`,
    singleton `{{x}}` and union `\u`) is also defined in the Metatheory
    library.  *)


(***********************************************************************)
(** * Opening *)
(***********************************************************************)

(** Opening replaces an index with a term.  It corresponds to informal
    substitution for a bound variable, such as in the rule for beta
    reduction.  Note that only "dangling" indices (those that do not
    refer to any abstraction) can be opened.  Opening has no effect for
    terms that are locally closed.

    Natural numbers are just an inductive datatype with two constructors:
    [O] (as in the letter 'oh', not 'zero') and [S], defined in
    Coq.Init.Datatypes.  Coq allows literal natural numbers to be written
    using standard decimal notation, e.g., 0, 1, 2, etc.  The function
    [lt_eq_lt_dec] compares its two arguments for ordering.

    We do not assume that zero is the only unbound index in the term.
    Consequently, we must substract one when we encounter other unbound
    indices (i.e. the [inright] case).

    However, we do assume that the argument [u] is locally closed.  This
    assumption simplifies the implementation since we do not need to
    shift indices in [u] when passing under a binder. *)

Fixpoint open_term_wrt_term_rec (k:nat) (u:term) (e:term) {struct e}: term :=
  match e with
  | (var_b n) =>
      match lt_eq_lt_dec n k with
        | inleft (left _)  => var_b n
        | inleft (right _) => u
        | inright _        => var_b (n-1)
      end
  | (var_f x)   => var_f x
  | (abs t)     => abs (open_term_wrt_term_rec (S k) u t)
  | (app t a)   => app (open_term_wrt_term_rec k u t) (open_args_wrt_term_rec k u a)
  end
with open_args_wrt_term_rec (k:nat) (u:term) (a:gmargs) {struct a}: gmargs :=
  match a with                  
  | (args t l c) => args (open_term_wrt_term_rec k u t)
                         (open_alist_wrt_term_rec k u l) 
                         (open_cont_wrt_term_rec k u c)        (*  ??????? *)
  end
with open_alist_wrt_term_rec (k:nat) (u:term) (l:alist) {struct l}: alist :=
  match l with
  | anil        => anil
  | acons t l1  => acons (open_term_wrt_term_rec k u t) (open_alist_wrt_term_rec k u l1)
  end
with open_cont_wrt_term_rec (k:nat) (u:term) (c:cont) {struct c}: cont :=
  match c with
  | (cabs t)  => cabs (open_term_wrt_term_rec (S k) u t)      (*  ??????? *)
  end.


Definition open_term_wrt_term t u := open_term_wrt_term_rec 0 u t.
Definition open_args_wrt_term a u := open_args_wrt_term_rec 0 u a.
Definition open_alist_wrt_term l u := open_alist_wrt_term_rec 0 u l.
Definition open_cont_wrt_term c u := open_cont_wrt_term_rec 0 u c.


(***********************************************************************)
(** * Closing *)
(***********************************************************************)


Require Import Arith.Bool_nat.

Fixpoint close_term_rec (n : nat) (x : var) (t : term) : term :=
  match t with
    | abs t => abs (close_term_rec (S n) x t)
    | var_f y => if x == y then var_b n else var_f y
    | var_b m => if lt_ge_dec m n then var_b m else var_b (S m)
    | app t (args u l (cabs v)) =>
      app (close_term_rec n x t)
          (args (close_term_rec n x u)
                (close_list_rec n x l)
                (cabs (close_term_rec (S n) x v)))
  end
with close_list_rec (n:nat) (x:var) (l: alist) : alist :=
       match l with
       | anil => anil
       | acons t l => acons (close_term_rec n x t) (close_list_rec n x l)
       end.

Definition close_term x e := close_term_rec 0 x e.


(***********************************************************************)
(** De Bruijn occurence Test *)
(***********************************************************************)

Fixpoint testINterm_rec (k:nat) (e:term) : bool :=
  match e with
  | (var_b n) =>
      match lt_eq_lt_dec n k with
        | inleft (left _)  => false
        | inleft (right _) => true
        | inright _        => false
      end
  | (var_f x)   => false    
  | (abs t)     => testINterm_rec (S k) t
  | (app t a)   => (testINterm_rec k t) || (testINargs_rec k a)
  end
with testINargs_rec (k:nat) (a:gmargs) : bool :=
  match a with
  | (args t l c)  => (testINterm_rec k t) || (testINalist_rec k l) || (testINcont_rec k c)
  end
with testINalist_rec (k:nat) (l:alist) : bool :=
  match l with
  | anil        => false
  | acons t l1  => (testINterm_rec k t) || (testINalist_rec k l1)
  end
with testINcont_rec (k:nat) (c:cont) : bool :=
  match c with
  | (cabs t)  => testINterm_rec (S k) t
  end.


Definition in_term t  := testINterm_rec 0 t.
Definition in_args a  := testINargs_rec 0 a.
Definition in_alist l := testINalist_rec 0 l.
Definition in_cont c  := testINcont_rec 0 c.

Lemma testIN_var_b : forall k n, testINterm_rec k (var_b n) = false -> k <> n.
Proof.
  intros k n H. simpl in H. destruct (lt_eq_lt_dec n k).
  - destruct s.
    + intuition.
    + discriminate H.
  - intuition.
Qed.


Lemma testIN_open_rec_2 : forall e,
    (forall t k, testINterm_rec k t = false -> open_term_wrt_term_rec k e t = t) /\
    (forall a k, testINargs_rec k a = false -> open_args_wrt_term_rec k e a = a) /\
    (forall l k, testINalist_rec k l = false -> open_alist_wrt_term_rec k e l = l) /\
    (forall c k, testINcont_rec k c = false -> open_cont_wrt_term_rec k e c = c).
Proof.
  intros e.
  induction e using term_ind_4 with
  (P0 := fun a => forall k, testINargs_rec k a = false -> open_args_wrt_term_rec k _ a = a)
  (P1 := fun l => forall k, testINalist_rec k l = false -> open_alist_wrt_term_rec k _ l = l)
  (P2 := fun c => forall k, testINcont_rec k c = false -> open_cont_wrt_term_rec k _ c = c).

  repeat split.
  intros.
Admitted.


(* MJF: TODO ;) *)

Lemma testIN_open_rec : forall e,
    (forall t k, testINterm_rec k t = false -> open_term_wrt_term_rec k e t = t) /\
    (forall a k, testINargs_rec k a = false -> open_args_wrt_term_rec k e a = a) /\
    (forall l k, testINalist_rec k l = false -> open_alist_wrt_term_rec k e l = l) /\
    (forall c k, testINcont_rec k c = false -> open_cont_wrt_term_rec k e c = c).
Proof.
Admitted.
(*   intros e. *)
(*   apply (term_gmargs_alist_cont_mutind *)
(*            (fun t => forall k, testINterm_rec k t = false -> open_term_wrt_term_rec k e t = t)  *)
(*            (fun a => forall k, testINargs_rec k a = false -> open_args_wrt_term_rec k e a = a)  *)
(*            (fun l => forall k, testINalist_rec k l = false -> open_alist_wrt_term_rec k e l = l)  *)
(*            (fun c => forall k, testINcont_rec k c = false -> open_cont_wrt_term_rec k e c = c)); intros. *)
(*   - apply testIN_var_b in H. simpl. destruct (lt_eq_lt_dec n k). *)
(*     + destruct s. *)
(*       * reflexivity. *)
(*       * exfalso. auto. *)
(*     + reflexivity. *)
(*   - reflexivity. *)
(*   - simpl. f_equal. simpl in H0. apply H. assumption. *)
(*   - simpl. f_equal. *)
(*     + apply H. simpl in H1. apply orb_false_elim in H1. destruct H1. assumption. *)
(*     + apply H0. simpl in H1. apply orb_false_elim in H1; destruct H1; assumption.  *)
(*   - simpl. f_equal. *)
(*     + apply H. simpl in H2. apply orb_false_elim in H2. destruct H2. *)
(*       apply orb_false_elim in H2. destruct H2. assumption. *)
(*     + apply H0. simpl in H2. apply orb_false_elim in H2. destruct H2. *)
(*       apply orb_false_elim in H2. destruct H2. assumption. *)
(*     + apply H1. simpl in H2. apply orb_false_elim in H2. destruct H2. assumption. *)
(*   - reflexivity. *)
(*   - simpl. f_equal. *)
(*     + apply H. simpl in H1. apply orb_false_elim in H1. destruct H1. assumption. *)
(*     + apply H0. simpl in H1.  apply orb_false_elim in H1. destruct H1. assumption. *)
(*   - simpl. f_equal. apply H. simpl in H0. assumption. *)
(* Qed.     *)

Lemma testIN_openT_rec : forall e t k, testINterm_rec k t = false -> open_term_wrt_term_rec k e t = t.
Proof. apply testIN_open_rec. Qed.

Lemma testIN_openA_rec : forall e a k, testINargs_rec k a = false -> open_args_wrt_term_rec k e a = a.
Proof. apply testIN_open_rec. Qed.

Lemma testIN_openL_rec : forall e l k, testINalist_rec k l = false -> open_alist_wrt_term_rec k e l = l.
Proof. apply testIN_open_rec. Qed.

Lemma testIN_openC_rec : forall e c k, testINcont_rec k c = false -> open_cont_wrt_term_rec k e c = c.
Proof. apply testIN_open_rec. Qed.



(***********************************************************************)
(** * Local closure *)
(***********************************************************************)

(** Recall that [term] admits terms that contain unbound indices.  We say
    that a term is locally closed when no indices appearing in it are
    unbound.  The proposition [lc_term t] holds when an expression [t] is
    locally closed.

    The inductive definition below formalizes local closure such that the
    resulting induction principle serves as the structural induction
    principle over (locally closed) terms.  In particular, unlike
    induction for type [term], there are no cases for bound variables.
    Thus, the induction principle corresponds more closely to informal
    practice than the one arising from the definition of pre-terms.  *)


Inductive lc_term : term -> Prop :=
 | lc_var_f : forall (x:var),
     lc_term (var_f x)
 | lc_abs : forall (t:term),
     (forall x , lc_term (open_term_wrt_term t (var_f x)))  ->
     lc_term (abs t)
 | lc_app : forall (t:term) (a:gmargs),
     lc_term t ->
     lc_gmargs a ->
     lc_term (app t a)
with lc_gmargs : gmargs -> Prop := 
 | lc_args : forall (u:term) (l:alist) (c:cont),
     lc_term u ->
     lc_alist l ->
     lc_cont c ->
     lc_gmargs (args u l c)
with lc_alist : alist -> Prop := 
 | lc_anil : lc_alist anil
 | lc_acons : forall (u:term) (l:alist),
     lc_term u ->
     lc_alist l ->
     lc_alist (acons u l)
with lc_cont : cont -> Prop := 
 | lc_cabs : forall (t:term),
     (forall x , lc_term (open_term_wrt_term t (var_f x)))  ->      
     lc_cont (cabs t).



Scheme lc_term_ind_4 := Induction for lc_term Sort Prop
  with lc_gmargs_ind_4 := Induction for lc_gmargs Sort Prop
  with lc_alist_ind_4 := Induction for lc_alist Sort Prop   
  with lc_cont_ind_4 := Induction for lc_cont Sort Prop.  


Combined Scheme lc_mutind from
         lc_term_ind_4, lc_gmargs_ind_4, lc_alist_ind_4, lc_cont_ind_4.

Hint Constructors lc_term lc_gmargs lc_alist lc_cont.


(***********************************************************************)
(** * Notations *)
(***********************************************************************)


(** Many common applications of opening replace index zero with an
    expression or variable.  The following definition provides a
    convenient shorthand for such uses.  Note that the order of
    arguments is switched relative to the definition above.  For
    example, [(open t x)] can be read as "substitute the variable [x]
    for index [0] in [t]" and "open [t] with the variable [x]."
*)

Module LambdaJmNotations.
Notation "[ z ~> u ] e" := (subst_term u z e) (at level 0).
Notation substT u x t   := (subst_term u x t).
Notation substA u x a   := (subst_args u x a).
Notation substL u x l   := (subst_alist u x l).
Notation substC u x c   := (subst_cont u x c).

(*Notation open t1 t2     := (open_term_wrt_term t1 t2).*)
Notation "t ^ x"        := (open_term_wrt_term t (var_f x)).
Notation openT t1 t2    := (open_term_wrt_term t1 t2).
Notation openA a t      := (open_args_wrt_term a t).
Notation openL l t      := (open_alist_wrt_term l t).
Notation openC c t      := (open_cont_wrt_term c t).

Notation closeT x t    := (close_term x t).
Notation closeL x l      := (close_term x l).

Notation fvT t          := (fv_term t).
Notation fvA a          := (fv_args a).
Notation fvL l          := (fv_alist l).
Notation fvC c          := (fv_cont c).

Notation lcT t          := (lc_term t).
Notation lcA a          := (lc_gmargs a).
Notation lcL l          := (lc_alist l).
Notation lcC c          := (lc_cont c).

Notation "t ::: l"      := (acons t l) (at level 0, right associativity).

End LambdaJmNotations.

Include LambdaJmNotations.

(*************************************************************************)
(** ** about Substitution                                                *)
(*************************************************************************)

Lemma subst_eq_var: forall (x : var) u,
  [x ~> u](var_f x) = u.
Proof.
  intros x u. simpl. destruct (x==x) as [H1 | H1].
  - reflexivity.
  - apply False_ind. apply H1. exact (eq_refl x).
Qed.



Lemma subst_neq_var : forall (x y : var) u,
  y <> x -> [x ~> u](var_f y) = var_f y.
Proof.
  intros x y u H. simpl. destruct (y==x) as [H1|H1].
  - contradiction.
  - reflexivity.
Qed.


Lemma subst_same : forall y,
    (forall e, (subst_term (var_f y) y e) = e) /\
    (forall a, (subst_args (var_f y) y a) = a) /\
    (forall l, (subst_alist (var_f y) y l) = l) /\
    (forall c, (subst_cont (var_f y) y c) = c).
Proof.
  intros.
  apply (term_gmargs_alist_cont_mutind 
        (fun e => (subst_term (var_f y) y e) = e)
        (fun a => (subst_args (var_f y) y a) = a)
        (fun l => (subst_alist (var_f y) y l) = l)
        (fun c => (subst_cont (var_f y) y c) = c)).
  - reflexivity.
  - simpl. intros. destruct (x==y) as [H | H]. 
    + rewrite <- H. reflexivity.
    + auto.
  - intros. simpl. rewrite -> H. reflexivity.
  - intros. simpl. rewrite -> H. rewrite -> H0. reflexivity.
  - intros. simpl. rewrite -> H, H0, H1. reflexivity.
  - reflexivity.
  - intros. simpl. rewrite -> H, H0. reflexivity.   
  - intros. simpl. rewrite -> H. reflexivity.   
Qed.


Lemma subst_term_same : forall y e, [y ~> var_f y] e = e.
Proof.  apply subst_same. Qed.

Lemma subst_args_same : forall y a, substA (var_f y) y a = a.
Proof. apply subst_same. Qed.

Lemma subst_alist_same : forall y l, substL (var_f y) y l = l.
Proof.  apply subst_same. Qed.

Lemma subst_cont_same : forall y c, substC (var_f y) y c = c.
Proof.  apply subst_same. Qed.



(*************************************************************************)
(** ** about Free variables                                              *)
(*************************************************************************)

(** The function [fv_exp] calculates the set of free variables in an
    expression.  This function returns a value of type `atoms` --- a finite
    set of variable names.  *)

(** Demo [fsetdec]

   The tactic [fsetdec] solves a certain class of propositions
   involving finite sets. See the documentation in [FSetWeakDecide]
   for a full specification.
*)

Lemma fsetdec_demo : forall (x : atom) (S : atoms),
  x `in` (singleton x `union` S).
Proof.
  fsetdec.
Qed.

(** *** 
    To show the ease of reasoning with these definitions, we will prove a
    standard result from lambda calculus: if a variable does not appear free
    in a term, then substituting for it has no effect.

    HINTS: Prove this lemma by induction on the terms.

    - You will need to use [simpl] in many cases.  You can [simpl] everything
      everywhere (including hypotheses) with the pattern [simpl in *].

    - Part of this proof includes a false assumption about free variables.
      Destructing this hypothesis produces a goal about finite set membership
      that is solvable by [fsetdec].

    - The [f_equal] tactic converts a goal of the form [f e1 = f e1'] in to
      one of the form [e1 = e1'], and similarly for [f e1 e2 = f e1' e2'],
      etc.  *)


Lemma subst_fresh_eq : forall (x : var),
    (forall e u, x `notin` fv_term e -> (subst_term u x e) = e) /\
    (forall a u, x `notin` fv_args a -> (subst_args u x a) = a) /\
    (forall l u, x `notin` fv_alist l -> (subst_alist u x l) = l) /\
    (forall c u, x `notin` fv_cont c -> (subst_cont u x c) = c).
Proof.
  intros.
  apply (term_gmargs_alist_cont_mutind
        (fun e => (forall u, x `notin` fv_term e -> (subst_term u x e) = e))
        (fun a => (forall u, x `notin` fv_args a -> (subst_args u x a) = a))
        (fun l => (forall u, x `notin` fv_alist l -> (subst_alist u x l) = l))
        (fun c => (forall u, x `notin` fv_cont c -> (subst_cont u x c) = c)));
    intros; simpl in *.
  - reflexivity.
  - destruct (x0==x) as [H1|H1].
    + destruct H. auto. 
    + reflexivity.
  - apply (H u) in H0. f_equal. assumption. (*rewrite -> H0. reflexivity.*)
  - assert (H': (x `notin` (fv_term t)) /\ (x `notin` (fv_args a))).
    + fsetdec.
    + destruct H'. apply (H u) in H2. apply (H0 u) in H3. f_equal; assumption.
  - assert (H': (x `notin` fv_term u) /\ (x `notin` fv_alist l) /\ (x `notin` fv_cont c)).
    + fsetdec.
    + destruct H'. destruct H4.
      apply (H u0) in H3. apply (H0 u0) in H4. apply (H1 u0) in H5.
      f_equal; assumption.
  - reflexivity.
  - assert (H': (x `notin` (fv_term t)) /\ (x `notin` (fv_alist l))).
    + fsetdec.
    + destruct H'. apply (H u) in H2. apply (H0 u) in H3. f_equal; assumption.
  - apply (H u) in H0. f_equal; assumption.
Qed.


Lemma subst_term_fresh_eq : forall x e u,  x `notin` fvT e -> [x ~> u] e = e.
Proof. apply subst_fresh_eq. Qed.

Lemma subst_args_fresh_eq : forall x a u,  x `notin` fvA a -> substA u x a = a.
Proof. apply subst_fresh_eq. Qed.

Lemma subst_alist_fresh_eq : forall x l u,  x `notin` fvL l -> substL u x l = l.
Proof. apply subst_fresh_eq. Qed.

Lemma subst_cont_fresh_eq : forall x c u,  x `notin` fvC c -> substC u x c = c.
Proof. apply subst_fresh_eq. Qed.


(**
   Step through the proof that free variables are not introduced by substitution.

   This proof actually is very automatable ([simpl in *; auto.] takes care of
   all but the var_f case), but the explicit proof below demonstrates two
   parts of the finite set library. These two parts are the tactic
   [destruct_notin] and the lemma [notin_union], both defined in the module
   [FSetWeakNotin].

   Before stepping through this proof, you should go to that module to read
   about those definitions and see what other finite set reasoning is
   available.

 *)

Lemma fv_subst_term_notin : forall x y u,
   (forall e, x `notin` fv_term e -> x `notin` fv_term u ->
                x `notin` fv_term (subst_term u y e)) /\
   (forall a, x `notin` fv_args a -> x `notin` fv_term u ->
                x `notin` fv_args (subst_args u y a)) /\
   (forall l, x `notin` fv_alist l -> x `notin` fv_term u ->
                x `notin` fv_alist (subst_alist u y l)) /\
   (forall c, x `notin` fv_cont c -> x `notin` fv_term u ->
                x `notin` fv_cont (subst_cont u y c)).
Proof.
  intros.
  apply (term_gmargs_alist_cont_mutind
           (fun e => x `notin` fv_term e -> x `notin` fv_term u ->
                                x `notin` fv_term (subst_term u y e))
           (fun a => x `notin` fv_args a -> x `notin` fv_term u ->
                                x `notin` fv_args (subst_args u y a))
           (fun l => x `notin` fv_alist l -> x `notin` fv_term u ->
                                x `notin` fv_alist (subst_alist u y l))
           (fun c => x `notin` fv_cont c -> x `notin` fv_term u ->
                                x `notin` fv_cont (subst_cont u y c)));
    intros; simpl in *.
  - Case "var_b".
    assumption.
  - Case "var_f".
    destruct (x0 == y).
    + assumption.
    + simpl. assumption.  
  - Case "abs".
    auto.
  - Case "app".
    destruct_notin. auto.
  - Case "args".
    destruct_notin. auto.
  - Case "anil".
    assumption.
  - Case "acons".
    destruct_notin. auto.
  - Case "cabs".
    destruct_notin. auto.
Qed.

Lemma fv_term_subst_term_notin : forall x y u t,
    x `notin` fvT t -> x `notin` fvT u -> x `notin` fvT (subst_term u y t).
Proof. apply fv_subst_term_notin. Qed.

Lemma fv_args_subst_term_notin : forall x y u a,
    x `notin` fvA a -> x `notin` fvT u -> x `notin` fvA (substA u y a).
Proof. apply fv_subst_term_notin. Qed.

Lemma fv_alist_subst_term_notin : forall x y u l,
    x `notin` fvL l -> x `notin` fvT u -> x `notin` fvL (substL u y l).
Proof. apply fv_subst_term_notin. Qed.

Lemma fv_cont_subst_term_notin : forall x y u c,
    x `notin` fvC c -> x `notin` fvT u -> x `notin` fvC (substC u y c).
Proof. apply fv_subst_term_notin. Qed.


Lemma subst_fresh_same : forall u x,
    (forall e, x `notin` fv_term e ->  x `notin` fv_term (subst_term u x e)) /\
    (forall a, x `notin` fv_args a ->  x `notin` fv_args (subst_args u x a)) /\
    (forall l, x `notin` fv_alist l -> x `notin` fv_alist (subst_alist u x l)) /\
    (forall c, x `notin` fv_cont c ->  x `notin` fv_cont (subst_cont u x c)).
Proof.
  intros.
  apply (term_gmargs_alist_cont_mutind
           (fun e => x `notin` fv_term e ->  x `notin` fv_term (subst_term u x e))
           (fun a => x `notin` fv_args a ->  x `notin` fv_args (subst_args u x a))
           (fun l => x `notin` fv_alist l -> x `notin` fv_alist (subst_alist u x l))
           (fun c => x `notin` fv_cont c ->  x `notin` fv_cont (subst_cont u x c)));
    intros; simpl in *; auto. 
  destruct (x0 == x). 
  - destruct_notin. contradiction.
  - simpl. assumption. 
Qed.
  

Lemma subst_term_fresh_same : forall u x t,  x `notin` fvT t ->
                                        x `notin` fvT (subst_term u x t).
Proof. apply subst_fresh_same. Qed.

Lemma subst_args_fresh_same : forall u x a,  x `notin` fvA a ->
                                        x `notin` fvA (substA u x a).
Proof. apply subst_fresh_same. Qed.

Lemma subst_alist_fresh_same : forall u x l,  x `notin` fvL l ->
                                         x `notin` fvL (substL u x l).
Proof. apply subst_fresh_same. Qed.

Lemma subst_cont_fresh_same : forall u x c,  x `notin` fvC c ->
                                        x `notin` fvC (substC u x c).
Proof. apply subst_fresh_same. Qed.


Lemma fv_subst_term_fresh : forall x u,
    (forall e, x `notin` fv_term e -> fv_term (subst_term u x e) [=] fv_term e) /\
    (forall a, x `notin` fv_args a -> fv_args (subst_args u x a) [=] fv_args a) /\
    (forall l, x `notin` fv_alist l -> fv_alist (subst_alist u x l) [=] fv_alist l) /\
    (forall c, x `notin` fv_cont c -> fv_cont (subst_cont u x c) [=] fv_cont c).
Proof.
  intros.
  apply (term_gmargs_alist_cont_mutind
    (fun e => x `notin` fv_term e -> fv_term (subst_term u x e) [=] fv_term e) 
    (fun a => x `notin` fv_args a -> fv_args (subst_args u x a) [=] fv_args a) 
    (fun l => x `notin` fv_alist l -> fv_alist (subst_alist u x l) [=] fv_alist l) 
    (fun c => x `notin` fv_cont c -> fv_cont (subst_cont u x c) [=] fv_cont c));
    intros; simpl in *; auto. 
  - reflexivity.
  - destruct (x0==x).
    + destruct_notin. contradiction.
    + simpl. reflexivity.
  - destruct_notin. apply H in H1. apply H0 in NotInTac.
    rewrite -> H1, NotInTac. reflexivity.
  - destruct_notin. apply H in H2. apply H0 in NotInTac. apply H1 in NotInTac0.
    rewrite -> H2, NotInTac, NotInTac0. reflexivity.
  - reflexivity.
  - destruct_notin. apply H in H1. apply H0 in NotInTac.
    rewrite -> H1, NotInTac. reflexivity.
Qed.


Lemma fv_term_subst_term_fresh : forall x u t,  x `notin` fvT t ->
                                           fvT (subst_term u x t) [=] fvT t.
Proof. apply fv_subst_term_fresh. Qed.

Lemma fv_args_subst_term_fresh : forall x u a,  x `notin` fvA a ->
                                           fvA (substA u x a) [=] fvA a.
Proof. apply fv_subst_term_fresh. Qed.

Lemma fv_alist_subst_term_fresh : forall x u l,  x `notin` fvL l ->
                                            fvL (substL u x l) [=] fvL l.
Proof. apply fv_subst_term_fresh. Qed.

Lemma fv_cont_subst_term_fresh : forall x u c,   x `notin` fvC c ->
                                            fvC (substC u x c) [=] fvC c.
Proof. apply fv_subst_term_fresh. Qed.


Lemma fv_subst_exp_upper : forall x u,
    (forall t, fv_term (subst_term u x t) [<=] fv_term u `union` remove x (fv_term t)) /\
    (forall a, fv_args (subst_args u x a) [<=] fv_term u `union` remove x (fv_args a)) /\
    (forall l, fv_alist (subst_alist u x l) [<=] fv_term u `union` remove x (fv_alist l)) /\
    (forall c, fv_cont (subst_cont u x c) [<=] fv_term u `union` remove x (fv_cont c)).
Proof.
  intros.
  apply (term_gmargs_alist_cont_mutind
    (fun t => fv_term (subst_term u x t) [<=] fv_term u `union` remove x (fv_term t))
    (fun a => fv_args (subst_args u x a) [<=] fv_term u `union` remove x (fv_args a))
    (fun l => fv_alist (subst_alist u x l) [<=] fv_term u `union` remove x (fv_alist l))
    (fun c => fv_cont (subst_cont u x c) [<=] fv_term u `union` remove x (fv_cont c)));
    intros; simpl in *; auto. 
  - fsetdec.
  - destruct (x0==x).
    + fsetdec.
    + simpl. fsetdec.
  - fsetdec.
  - fsetdec.
  - fsetdec.
  - fsetdec.
Qed.

Lemma fv_term_subst_term_upper : forall x u t,
    fvT (substT u x t) [<=] fvT u `union` remove x (fvT t).
Proof. apply fv_subst_exp_upper. Qed.

Lemma fv_args_subst_args_upper : forall x u a,
    fvA (substA u x a) [<=] fvT u `union` remove x (fvA a).
Proof. apply fv_subst_exp_upper. Qed.

Lemma fv_alist_subst_alist_upper : forall x u l,
    fvL (substL u x l) [<=] fvT u `union` remove x (fvL l).
Proof. apply fv_subst_exp_upper. Qed.

Lemma fv_cont_subst_cont_upper : forall x u c,
    fvC (substC u x c) [<=] fvT u `union` remove x (fvC c).
Proof. apply fv_subst_exp_upper. Qed.




Lemma subst_open_wrt_term : forall u v x,  lcT u ->
  (forall e, substT u x (openT e v) = openT (substT u x e) (substT u x v)) /\
  (forall a, substA u x (openA a v) = openA (substA u x a) (substT u x v)) /\
  (forall l, substL u x (openL l v) = openL (substL u x l) (substT u x v)) /\
  (forall c, substC u x (openC c v) = openC (substC u x c) (substT u x v)) .
Proof.
  intros u v x H.
  apply (term_gmargs_alist_cont_mutind 
         (fun e => substT u x (openT e v) = openT (substT u x e) (substT u x v)) 
         (fun a => substA u x (openA a v) = openA (substA u x a) (substT u x v)) 
         (fun l => substL u x (openL l v) = openL (substL u x l) (substT u x v)) 
         (fun c => substC u x (openC c v) = openC (substC u x c) (substT u x v)));
    intros; simpl in *; auto.

     (* Require Export Metalib.LibDefaultSimp. *)
     (* unfold open_exp_wrt_exp; default_simp. *)
(* unfold open_term_wrt_term; default_step. *)

  - destruct n.
    + reflexivity.
    + reflexivity.
  - destruct (x0==x).
    + admit.
    + reflexivity.

Admitted.

Lemma subst_term_open_term_wrt_term : forall t e1 e2 x1,
    lcT e1 ->
    [x1 ~> e1] (openT t e2) = openT ([x1 ~> e1] t) ([x1 ~> e1] e2).
Proof.
  intros. apply (subst_open_wrt_term e1 e2 x1) in H.  apply H.
Qed.

Lemma subst_args_open_args_wrt_term :  forall a e1 e2 x1,
    lcT e1 ->
    substA e1 x1 (openA a e2) = openA (substA e1 x1 a) ([x1 ~> e1] e2). 
Proof.
  intros. apply (subst_open_wrt_term e1 e2 x1) in H. apply H.
Qed.


Lemma subst_alist_open_alist_wrt_term :  forall l e1 e2 x1,
    lcT e1 ->
    substL e1 x1 (openL l e2) = openL (substL e1 x1 l) ([x1 ~> e1] e2). 
Proof.
  intros. apply (subst_open_wrt_term e1 e2 x1) in H. apply H.
Qed.
  
Lemma subst_cont_open_cont_wrt_term :  forall c e1 e2 x1,
    lcT e1 ->
    substC e1 x1 (openC c e2) = openC (substC e1 x1 c) ([x1 ~> e1] e2). 
Proof.
  intros. apply (subst_open_wrt_term e1 e2 x1) in H. apply H.
Qed.



(** The lemma above is most often used with [e2] as some fresh
    variable. Therefore, it simplifies matters to define the following useful
    corollary.

    HINT: Do not use induction.  Rewrite with [subst_term_open_term_wrt_term] and
    [subst_neq_var].
*)

Lemma subst_term_var : forall x y u e,   y <> x -> lcT u ->
                                    ([x ~> u] e) ^ y = [x ~> u] (e ^ y).
Proof.
  intros. rewrite (subst_term_open_term_wrt_term e u (var_f y) x H0).
  apply (subst_neq_var x y u) in H. rewrite H. reflexivity.
Qed.

Lemma subst_args_var : forall (x y : var) u a,  y <> x -> lcT u ->
    openA (substA u x a) (var_f y) =  substA u x (openA a (var_f y)).
Proof.
  intros. rewrite (subst_args_open_args_wrt_term a u (var_f y) x H0).
  apply (subst_neq_var x y u) in H. rewrite H. reflexivity.
Qed.


Lemma subst_alist_var : forall (x y : var) u l,  y <> x -> lcT u ->
    openL (substL u x l) (var_f y) = substL u x (openL l (var_f y)).
Proof.
  intros. rewrite (subst_alist_open_alist_wrt_term l u (var_f y) x H0).
  apply (subst_neq_var x y u) in H. rewrite H. reflexivity.
Qed.


Lemma subst_cont_var : forall (x y : var) u c,  y <> x -> lcT u ->
    openC (substC u x c) (var_f y) = substC u x (openC c (var_f y)).
Proof.
  intros. rewrite (subst_cont_open_cont_wrt_term c u (var_f y) x H0).
  apply (subst_neq_var x y u) in H. rewrite H. reflexivity.
Qed.



(** This next lemma states that opening can be replaced with variable
    opening and substitution.

    This lemma, like many about [open_???_wrt_???], should be proven
    via induction on the term [e]. However, during this induction, the
    binding depth of the term changes, so to make sure that we have
    a flexible enough induction hypothesis, we must generalize the
    argument to [open_???_wrt_???_rec].  *)


Lemma subst_intro : forall (x : var) u,
    (forall e, x `notin` (fvT e) -> openT e u = substT u x (openT e (var_f x))) /\
    (forall a, x `notin` (fvA a) -> openA a u = substA u x (openA a (var_f x))) /\
    (forall l, x `notin` (fvL l) -> openL l u = substL u x (openL l (var_f x))) /\
    (forall c, x `notin` (fvC c) -> openC c u = substC u x (openC c (var_f x))).
Proof.
  intros x u; split;[ |split];[ | |split];
    [ intros e FV; unfold openT |
      intros a FV; unfold openA |
      intros l FV; unfold openL |
      intros c FV; unfold openC ];
    generalize 0.
 (* NOTE: The proofs of the 4 subgoals are equal. 
          A better proof script should be possible. *)
  - (* terms *)
    apply (term_gmargs_alist_cont_mutind
    (fun e => x `notin` fvT e -> forall n, open_term_wrt_term_rec n u e = 
                                  subst_term u x (open_term_wrt_term_rec n (var_f x) e))
    (fun a => x `notin` fvA a -> forall n, open_args_wrt_term_rec n u a =
                                  subst_args u x (open_args_wrt_term_rec n (var_f x) a))
    (fun l => x `notin` fvL l -> forall n, open_alist_wrt_term_rec n u l =
                                  subst_alist u x (open_alist_wrt_term_rec n (var_f x) l))
    (fun c => x `notin` fvC c -> forall n, open_cont_wrt_term_rec n u c =
                                  subst_cont u x (open_cont_wrt_term_rec n (var_f x) c)));
    intros; simpl.

    + destruct (lt_eq_lt_dec n n0).
      * destruct s.
        -- reflexivity.
        -- simpl. destruct (x==x).
           ++ reflexivity.
           ++ destruct n1.  reflexivity.
      * reflexivity.    
    + simpl in H. destruct_notin. destruct (x0==x).
      * contradiction.    
      * reflexivity.
    + f_equal. apply H. assumption. 
    + simpl in H1. destruct_notin. f_equal.
      * apply H. assumption.
      * apply H0. assumption.
    + f_equal.
      * apply H. simpl in H2. destruct_notin. assumption.
      * apply H0. simpl in H2. destruct_notin. assumption.
      * apply H1. simpl in H2. destruct_notin. assumption.
    + reflexivity. 
    + f_equal.
      * apply H. simpl in H1. destruct_notin. assumption.
      * apply H0. simpl in H1. destruct_notin. assumption.
    + f_equal. apply H. simpl in H0. assumption.
    + assumption.
    
  - (* gmargs *) 
    apply (term_gmargs_alist_cont_mutind
    (fun e => x `notin` fvT e -> forall n, open_term_wrt_term_rec n u e =
                                  subst_term u x (open_term_wrt_term_rec n (var_f x) e))
    (fun a => x `notin` fvA a -> forall n, open_args_wrt_term_rec n u a =
                                  subst_args u x (open_args_wrt_term_rec n (var_f x) a))
    (fun l => x `notin` fvL l -> forall n, open_alist_wrt_term_rec n u l =
                                  subst_alist u x (open_alist_wrt_term_rec n (var_f x) l))
    (fun c => x `notin` fvC c -> forall n, open_cont_wrt_term_rec n u c =
                                  subst_cont u x (open_cont_wrt_term_rec n (var_f x) c)));
      intros; simpl.
    destruct (lt_eq_lt_dec n n0).
    + destruct s.
      * reflexivity.
      * simpl. destruct (x==x).
        -- reflexivity.
        -- destruct n1.  reflexivity.
    + reflexivity.    
    + simpl in H. destruct_notin. destruct (x0==x).
      * contradiction.    
      * reflexivity.
    + f_equal; apply H; simpl in H0; assumption. 
    + f_equal; [apply H | apply H0]; simpl in H1; destruct_notin; assumption.
    + f_equal; [apply H | apply H0 |apply H1]; simpl in H2; destruct_notin; assumption.
    + reflexivity. 
    + f_equal; [apply H | apply H0]; simpl in H1; destruct_notin; assumption.
    + f_equal; apply H; simpl in H0; assumption. 
    + assumption.

  - (* alist *) 
    apply (term_gmargs_alist_cont_mutind
    (fun e => x `notin` fv_term e -> forall n, open_term_wrt_term_rec n u e =
                                      subst_term u x (open_term_wrt_term_rec n (var_f x) e))
    (fun a => x `notin` fv_args a -> forall n, open_args_wrt_term_rec n u a =
                                      subst_args u x (open_args_wrt_term_rec n (var_f x) a))
    (fun l => x `notin` fv_alist l -> forall n, open_alist_wrt_term_rec n u l =
                                       subst_alist u x (open_alist_wrt_term_rec n (var_f x) l))
    (fun c => x `notin` fv_cont c -> forall n, open_cont_wrt_term_rec n u c =
                                      subst_cont u x (open_cont_wrt_term_rec n (var_f x) c)));
      intros; simpl.
    destruct (lt_eq_lt_dec n n0).
    + destruct s.
      * reflexivity.
      * simpl. destruct (x==x).
        -- reflexivity.
        -- destruct n1.  reflexivity.
    + reflexivity.    
    + simpl in H. destruct_notin. destruct (x0==x).
      * contradiction.    
      * reflexivity.
    + f_equal; apply H; simpl in H0; assumption. 
    + f_equal; [apply H | apply H0]; simpl in H1; destruct_notin; assumption.
    + f_equal; [apply H | apply H0 |apply H1]; simpl in H2; destruct_notin; assumption.
    + reflexivity. 
    + f_equal; [apply H | apply H0]; simpl in H1; destruct_notin; assumption.
    + f_equal; apply H; simpl in H0; assumption. 
    + assumption.

  - (* cont *) 
    apply (term_gmargs_alist_cont_mutind
    (fun e => x `notin` fv_term e -> forall n, open_term_wrt_term_rec n u e =
                                      subst_term u x (open_term_wrt_term_rec n (var_f x) e))
    (fun a => x `notin` fv_args a -> forall n, open_args_wrt_term_rec n u a =
                                      subst_args u x (open_args_wrt_term_rec n (var_f x) a))
    (fun l => x `notin` fv_alist l -> forall n, open_alist_wrt_term_rec n u l =
                                       subst_alist u x (open_alist_wrt_term_rec n (var_f x) l))
    (fun c => x `notin` fv_cont c -> forall n, open_cont_wrt_term_rec n u c =
                                      subst_cont u x (open_cont_wrt_term_rec n (var_f x) c)));
      intros; simpl.
    destruct (lt_eq_lt_dec n n0).
    + destruct s.
      * reflexivity.
      * simpl. destruct (x==x).
        -- reflexivity.
        -- destruct n1.  reflexivity.
    + reflexivity.    
    + simpl in H. destruct_notin. destruct (x0==x).
      * contradiction.    
      * reflexivity.
    + f_equal; apply H; simpl in H0; assumption. 
    + f_equal; [apply H | apply H0]; simpl in H1; destruct_notin; assumption.
    + f_equal; [apply H | apply H0 |apply H1]; simpl in H2; destruct_notin; assumption.
    + reflexivity. 
    + f_equal; [apply H | apply H0]; simpl in H1; destruct_notin; assumption.
    + f_equal; apply H; simpl in H0; assumption. 
    + assumption.
Qed.

Lemma subst_term_intro : forall x u t,  x `notin` (fvT t) ->
                                   openT t u = subst_term u x (openT t (var_f x)).
Proof. apply subst_intro. Qed.

Lemma subst_args_intro : forall x u a,  x `notin` (fvA a) ->
                                   openA a u = substA u x (openA a (var_f x)). 
Proof. apply subst_intro. Qed.

Lemma subst_alist_intro : forall x u l,  x `notin` (fvL l) ->
                                    openL l u = substL u x (openL l (var_f x)). 
Proof. apply subst_intro. Qed.

Lemma subst_cont_intro : forall x u c,  x `notin` (fvC c) ->
                                   openC c u = substC u x (openC c (var_f x)). 
Proof. apply subst_intro. Qed.



(** NLemmas about the free variables of an opened term.

    The structure of this proof follows that of the proof above. We
    prove this by induction on the term [e1], after appropriately
    generalizing the induction hypothesis. We use [fsetdec] for
    reasoning about properties of atom sets. Note that we can
    [rewrite] with atom set inequalities in the hypotheses list. *)

Lemma fv_open_wrt_term_upper :  forall u,
    (forall e, fvT (openT e u) [<=] fvT e `union` fvT u) /\
    (forall a, fvA (openA a u) [<=] fvA a `union` fvT u) /\
    (forall l, fvL (openL l u) [<=] fvL l `union` fvT u) /\
    (forall c, fvC (openC c u) [<=] fvC c `union` fvT u) . 
Proof.
  intros u; split;[ |split];[ | |split];
    [ intros e; unfold openT |
      intros a; unfold openA |
      intros l; unfold openL |
      intros c; unfold openC ];
    generalize 0.
(* NOTE: The proofs of the 4 subgoals are equal. 
         A better proof script should be possible. *)
  
  - (* terms *)
    apply (term_gmargs_alist_cont_mutind
             (fun e => forall n, fvT (open_term_wrt_term_rec n u e) [<=] fvT e `union` fvT u)
             (fun a => forall n, fvA (open_args_wrt_term_rec n u a) [<=] fvA a `union` fvT u)
             (fun l => forall n, fvL (open_alist_wrt_term_rec n u l) [<=] fvL l `union` fvT u)
             (fun c => forall n, fvC (open_cont_wrt_term_rec n u c) [<=] fvC c `union` fvT u));
      intros; simpl.
    + destruct (lt_eq_lt_dec n n0). 
      * destruct s.
        -- simpl. fsetdec.
        -- fsetdec.
      * simpl. fsetdec.
    + fsetdec.
    + apply H.
    + rewrite H. rewrite H0. fsetdec.
    + rewrite H. rewrite H0. rewrite H1. fsetdec.
    + fsetdec.
    + rewrite H. rewrite H0. fsetdec.
    + rewrite H. fsetdec.

  - (* args *)
    apply (term_gmargs_alist_cont_mutind
             (fun e => forall n, fvT (open_term_wrt_term_rec n u e) [<=] fvT e `union` fvT u)
             (fun a => forall n, fvA (open_args_wrt_term_rec n u a) [<=] fvA a `union` fvT u)
             (fun l => forall n, fvL (open_alist_wrt_term_rec n u l) [<=] fvL l `union` fvT u)
             (fun c => forall n, fvC (open_cont_wrt_term_rec n u c) [<=] fvC c `union` fvT u));
      intros; simpl.
    + destruct (lt_eq_lt_dec n n0). 
      * destruct s.
        -- simpl; fsetdec.
        -- fsetdec.
      * simpl; fsetdec.
    + fsetdec.
    + apply H.
    + rewrite H, H0; fsetdec.
    + rewrite H, H0, H1; fsetdec.
    + fsetdec.
    + rewrite H, H0; fsetdec.
    + rewrite H; fsetdec.

  - (* alist *)
    apply (term_gmargs_alist_cont_mutind
             (fun e => forall n, fvT (open_term_wrt_term_rec n u e) [<=] fvT e `union` fvT u)
             (fun a => forall n, fvA (open_args_wrt_term_rec n u a) [<=] fvA a `union` fvT u)
             (fun l => forall n, fvL (open_alist_wrt_term_rec n u l) [<=] fvL l `union` fvT u)
             (fun c => forall n, fvC (open_cont_wrt_term_rec n u c) [<=] fvC c `union` fvT u));
      intros; simpl.
    + destruct (lt_eq_lt_dec n n0). 
      * destruct s.
        -- simpl; fsetdec.
        -- fsetdec.
      * simpl; fsetdec.
    + fsetdec.
    + apply H.
    + rewrite H, H0; fsetdec.
    + rewrite H, H0, H1; fsetdec.
    + fsetdec.
    + rewrite H, H0; fsetdec.
    + rewrite H; fsetdec.

  - (* cont *)
    apply (term_gmargs_alist_cont_mutind
             (fun e => forall n, fvT (open_term_wrt_term_rec n u e) [<=] fvT e `union` fvT u)
             (fun a => forall n, fvA (open_args_wrt_term_rec n u a) [<=] fvA a `union` fvT u)
             (fun l => forall n, fvL (open_alist_wrt_term_rec n u l) [<=] fvL l `union` fvT u)
             (fun c => forall n, fvC (open_cont_wrt_term_rec n u c) [<=] fvC c `union` fvT u));
      intros; simpl.
    + destruct (lt_eq_lt_dec n n0). 
      * destruct s.
        -- simpl; fsetdec.
        -- fsetdec.
      * simpl; fsetdec.
    + fsetdec.
    + apply H.
    + rewrite H, H0; fsetdec.
    + rewrite H, H0, H1; fsetdec.
    + fsetdec.
    + rewrite H, H0; fsetdec.
    + rewrite H; fsetdec.
Qed.
      

Lemma fv_term_open_term_wrt_term_upper : forall u e,
    fvT (openT e u) [<=] fvT e `union` fvT u. 
Proof.
  intro u. apply fv_open_wrt_term_upper.
Qed.

Lemma fv_args_open_args_wrt_term_upper : forall u a,
    fvA  (openA a u) [<=] fvA a `union` fvT u. 
Proof.
  intro u. apply fv_open_wrt_term_upper.
Qed.

Lemma fv_alist_open_alist_wrt_term_upper : forall u l,
    fvL (openL l u) [<=] fvL l `union` fvT u. 
Proof.
  intro u. apply fv_open_wrt_term_upper.
Qed.

Lemma fv_cont_open_cont_wrt_term_upper : forall u c,
    fvC (openC c u) [<=] fvC c `union` fvT u. 
Proof.
  intro u. apply fv_open_wrt_term_upper.
Qed.


(*************************************************************************)
(** ** Forall quantification in [lc_???].                                *)
(*************************************************************************)


Lemma lc_abs_exists : forall (x : var) t,  lcT (t ^ x) -> lcT (abs t).
Admitted.

Lemma lc_cabs_exists : forall (x : var) v,  lcT (v ^ x) -> lcC (cabs v).
Admitted.


Lemma subst_lc : forall (x : var) u,
    (forall e, lc_term e -> lc_term u -> lc_term (subst_term u x e)) /\
    (forall a, lc_gmargs a -> lc_term u -> lc_gmargs (subst_args u x a)) /\
    (forall l, lc_alist l -> lc_term u -> lc_alist (subst_alist u x l)) /\
    (forall c, lc_cont c -> lc_term u -> lc_cont (subst_cont u x c)).
Proof.
  intros x u; split; [ |split];[ | |split].
  
  - (* terms *)
    apply (lc_mutind
             (fun e (_:lc_term e) => lc_term u -> lc_term (subst_term u x e)) 
             (fun a (_:lc_gmargs a) => lc_term u -> lc_gmargs (subst_args u x a)) 
             (fun l (_:lc_alist l) => lc_term u -> lc_alist (subst_alist u x l)) 
             (fun c (_:lc_cont c) => lc_term u -> lc_cont (subst_cont u x c))).
    + intros. simpl. destruct (x0==x); auto.
    + simpl. intros. 
      pick fresh x0 for {{x}}.  (* a tactic to generate x0 <> x *)
      apply (lc_abs_exists x0).
      rewrite subst_term_var.
      * apply H. assumption.
      * destruct_notin. auto.
      * assumption.
    + simpl. intros. constructor; auto.
    + simpl. intros. constructor; auto.
    + simpl. intros. constructor.
    + simpl. intros. constructor; auto.
    + simpl. intros.
      pick fresh x0 for {{x}}. 
      apply (lc_cabs_exists x0).
      rewrite subst_term_var; auto.
    
  - (* gmargs *)
    apply (lc_mutind
             (fun e (_:lc_term e) => lc_term u -> lc_term (subst_term u x e)) 
             (fun a (_:lc_gmargs a) => lc_term u -> lc_gmargs (subst_args u x a)) 
             (fun l (_:lc_alist l) => lc_term u -> lc_alist (subst_alist u x l)) 
             (fun c (_:lc_cont c) => lc_term u -> lc_cont (subst_cont u x c))).
    + intros. simpl. destruct (x0==x); auto.
    + simpl. intros. 
      pick fresh x0 for {{x}}. 
      apply (lc_abs_exists x0).
      rewrite subst_term_var; auto.
    + simpl. intros. constructor; auto.
    + simpl. intros. constructor; auto.
    + simpl. intros. constructor.
    + simpl. intros. constructor; auto.
    + simpl. intros.
      pick fresh x0 for {{x}}.  
      apply (lc_cabs_exists x0).
      rewrite subst_term_var; auto.
    
  - (* alist *)
    apply (lc_mutind
             (fun e (_:lc_term e) => lc_term u -> lc_term (subst_term u x e)) 
             (fun a (_:lc_gmargs a) => lc_term u -> lc_gmargs (subst_args u x a)) 
             (fun l (_:lc_alist l) => lc_term u -> lc_alist (subst_alist u x l)) 
             (fun c (_:lc_cont c) => lc_term u -> lc_cont (subst_cont u x c))).
    + intros. simpl. destruct (x0==x); auto.
    + simpl. intros. 
      pick fresh x0 for {{x}}. 
      apply (lc_abs_exists x0).
      rewrite subst_term_var; auto.
    + simpl. intros. constructor; auto.
    + simpl. intros. constructor; auto.
    + simpl. intros. constructor.
    + simpl. intros. constructor; auto.
    + simpl. intros.
      pick fresh x0 for {{x}}.  
      apply (lc_cabs_exists x0).
      rewrite subst_term_var; auto.
    
  - (* cont *)
    apply (lc_mutind
             (fun e (_:lc_term e) => lc_term u -> lc_term (subst_term u x e)) 
             (fun a (_:lc_gmargs a) => lc_term u -> lc_gmargs (subst_args u x a)) 
             (fun l (_:lc_alist l) => lc_term u -> lc_alist (subst_alist u x l)) 
             (fun c (_:lc_cont c) => lc_term u -> lc_cont (subst_cont u x c))).
    + intros. simpl. destruct (x0==x); auto.
    + simpl. intros. 
      pick fresh x0 for {{x}}. 
      apply (lc_abs_exists x0).
      rewrite subst_term_var; auto.
    + simpl. intros. constructor; auto.
    + simpl. intros. constructor; auto.
    + simpl. intros. constructor.
    + simpl. intros. constructor; auto.
    + simpl. intros.
      pick fresh x0 for {{x}}. 
      apply (lc_cabs_exists x0).
      rewrite subst_term_var; auto.
Qed.    



Lemma subst_lc_term : forall x u e,  lcT e -> lcT u -> lcT (subst_term u x e).
Proof. apply subst_lc. Qed.

Lemma subst_lc_args : forall x u a,  lc_gmargs a -> lcT u -> lcA (substA u x a).
Proof. apply subst_lc. Qed.

Lemma subst_lc_alist : forall x u l,  lcL l -> lcT u -> lcL (substL u x l).
Proof. apply subst_lc. Qed.

Lemma subst_lc_cont : forall x u c,  lcC c -> lcT u -> lcC (substC u x c).
Proof. apply subst_lc. Qed.


(*************************************************************************)
(** ** Local closure and relations                                       *)
(*************************************************************************)

(** All of our semantics only hold for locally closed terms, and we can
    prove that.
*)


(* Lemma open_app : forall u t a, openT (app t a) u = app (openT t u) (openA a u). *)
(* Proof. reflexivity. Qed. *)

(* Lemma open_args : forall u t l c, openA (args t l c) u = args (openT t u) (openL l u) (openC c u). *)
(* Proof. reflexivity. Qed. *)

(* Lemma  forall x a, lcA a -> lcA (openA a (var_f x)). *)
(* Proof. *)

(****************************** AQUI *********************************)


(* Lemma lc_open : forall u, lcT u -> *)
(*                      (forall t, lcT t -> lcT (openT t u)) /\ *)
(*                      (forall a, lcA a -> lcA (openA a u)) /\ *)
(*                      (forall l, lcL l -> lcL (openL l u)) /\ *)
(*                      (forall c, lcC c -> lcC (openC c u)) . *)
(* Proof. *)
(*     intros u H; split; [ |split]; [ | |split]; *)
(*     [ intros t; unfold openT | *)
(*       intros a; unfold openA | *)
(*       intros l; unfold openL | *)
(*       intros c; unfold openC ]; generalize 0; intros. *)
(*     apply (lc_mutind (fun t (_:lcT t) => lcT (open_term_wrt_term_rec n u t))  *)
(*                      (fun a (_:lcA a) => lcA (open_args_wrt_term_rec n u a)) *)
(*                      (fun l (_:lcL l) => lcL (open_alist_wrt_term_rec n u l)) *)
(*                      (fun c (_:lcC c) => lcC (open_cont_wrt_term_rec n u c))); *)
(*       intros; simpl; auto. *)
(*     - constructor. intros. unfold openT.  *)
(*       pick fresh x0 for {{x}}. *)
(*       apply (lc_abs_exists x0). *)


(*       pick fresh x0 for {{x}}.  (* a tactic to generate x0 <> x *) *)
(*       apply (lc_abs_exists x0). *)
(*       rewrite subst_term_var. *)

    
(*     - lc_abs_exists *)
(*       constructor. assumption. *)
(*   - intros. cbn. *)
  
  
(* Lemma mu_lc : forall a1 a2, muA a1 a2 -> lcA a1. *)
(* Proof. *)
(*   intros a1 a2 H. destruct H; auto. constructor.  *)
(*   - assumption. *)
(*   - assumption. *)
(*   - constructor. intros. rewrite open_app. constructor. *)
(*     + cbn. auto.  *)
(*     + rewrite open_args. constructor. *)





(*       Eval compute in fun t:term => *)
(*          (openT (app (var_b 0) (args (var_b 0) anil (cabs (var_b 0)))) t).  *)

(*     cbn. constructor. *)
(*     + auto.  *)
(*     + constructor. *)
(*       *  cbn. *)





